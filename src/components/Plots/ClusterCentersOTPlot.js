import Plot from 'react-plotly.js';
import { useState, useRef, useEffect } from 'react';


/**
 * clusterCenters holds all of the cluster centers generated by each report
 * recentClusterCenters holds only the most recent cluster centers generated by the latest report 
 * reportsCacheLength is an array which holds the cache length for each report 
 */
export default function ClusterCentersOT({ clusterCenters, reportsCacheLength }) {


    const plotContainer = useRef(null);
    const [dimensions, setDimensions] = useState({ width: 0, height: 0 });

    useEffect(() => {
        const resizeObserver = new ResizeObserver((entries) => {
            if (entries[0]) {
                const { width, height } = entries[0].contentRect;
                setDimensions({ width, height });
            }
        });

        if (plotContainer.current) {
            resizeObserver.observe(plotContainer.current);
        }

        return () => resizeObserver.disconnect();
    }, []);

    /**
     * cc stands for cluster centers.
     * By using a useState for the report index, it ensures that whenever the report index changes, the traces as defined below is computed 
     * on the new currentCenters. 
     */
    const [ccReportIndex, setCCReportIndex] = useState(clusterCenters.length);

    //playing tracks whether the user wants to use the playback functionality 
    const [playing, setPlaying] = useState(false);

    /*intervalValue is defined using useRef because it's not needed for rendering
    - it stores the ID of the setInterval timer
    */
    const intervalValue = useRef(null);

    //this keeps track of which report the user is viewing (has the graph on). It is an array of values 
    const currentCenters = clusterCenters[ccReportIndex] || [];


    //In plotly, a trace refers to a collection of data. 
    //The map is iterating through an array of values. 
    const traces = currentCenters.map((center, index) => ({
        x: center.map((_, i) => i + 1),
        y: center,
        type: 'scatter',
        mode: 'lines+markers',
        name: `Cluster ${index}`,
        line: { shape: 'linear' },
    }));

    const handleSliderChange = (e) => {
        setCCReportIndex(parseInt(e.target.value, 10));
    }

    const startPlayback = () => {
        if (intervalValue.current) return;   //if intervalValue has a value, don't go through with this function

        //intervalValue.current stores the ID returned by setInterval(callback, 1000)
        //by doing so, we are abel to cacnel it later on
        intervalValue.current = setInterval(() => {
            setCCReportIndex((prevIndex) => {
                const nextIndex = prevIndex + 1;
                if (nextIndex >= clusterCenters.length) {
                    return 0; // this loops back to beginning
                }
                return nextIndex;
            });
        }, 1000);
        setPlaying(true);
    };

    const stopPlayback = () => {
        clearInterval(intervalValue.current);
        intervalValue.current = null;
        setPlaying(false);
    };

    useEffect(() => {
        return () => clearInterval(intervalValue.current);
    }, []);

    return (
        <div>
            <div style={{ marginBottom: '10px' }}>
                <label>
                    Report Index: {ccReportIndex + 1}
                    <input
                        type="range"
                        min="0"
                        max={clusterCenters.length - 1}
                        value={ccReportIndex}
                        onChange={handleSliderChange}
                        style={{ width: '100%' }}
                    />
                </label>
                <div style={{ marginTop: '10px' }}>
                    {!playing ? (<button onClick={startPlayback}>Play &#9654;</button>) : (<button onClick={stopPlayback}>Pause &#x23f8;</button>)}
                </div>
            </div>

            {/* start of plot */}
            <div ref={plotContainer}>
                <Plot
                    data={traces}
                    layout={
                        {
                            title: {
                                text: `Cluster Centers from Report ${ccReportIndex + 1}`,
                            },
                            xaxis: { title: {text: 'Feature Index' }},
                            yaxis: { title:{text: 'Value'} },
                            autosize: true,
                            width: dimensions.width,
                            height: dimensions.height,
                            margin: { l: 40, r: 20, t: 40, b: 40 },
                            annotations: [
                                {
                                    text: `Cache Length: ${reportsCacheLength[ccReportIndex] || 0}`,
                                    xref: 'paper',
                                    yref: 'paper',
                                    x: 1,
                                    y: 1.02,
                                    showarrow: false,
                                    font: {
                                        size: 14,
                                        color: 'gray'
                                    },
                                    marginTop: '10px'
                                }
                            ],
                        }
                    }
                    config={{ responsive: true }}
                />
            </div>
            {/* end of plot */}
        </div>
    );
}