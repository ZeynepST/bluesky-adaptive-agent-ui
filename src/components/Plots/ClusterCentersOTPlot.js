import Plot from 'react-plotly.js';
import { useState, useRef, useEffect } from 'react';


/**
 * clusterCenters holds all of the cluster centers generated by each report
 * recentClusterCenters holds only the most recent cluster centers generated by the latest report 
 * reportsCacheLength is an array which holds the cache length for each report 
 */
export default function ClusterCentersOT({ clusterCenters, reportsCacheLength }) {

    /**
     * cc stands for cluster centers.
     * By using a useState for the report index, it ensures that whenever the report index changes, the traces as defined below is computed 
     * on the new currentCenters. 
     */
    const [ccReportIndex, setCCReportIndex] = useState(clusterCenters.length);

    //playing tracks whether the user wants to use the playback functionality 
    const [playing, setPlaying] = useState(false);

    /*intervalValue is defined using useRef because it's not needed for rendering
    - it stores the ID of the setInterval timer
    */
    const intervalValue = useRef(null);

    //this keeps track of which report the user is viewing (has the graph on). It is an array of values 
    const currentCenters = clusterCenters[ccReportIndex] || [];


    //In plotly, a trace refers to a collection of data. 
    //The map is iterating through an array of values. 
    const traces = currentCenters.map((center, index) => ({
        x: center.map((_, i) => i + 1),
        y: center,
        type: 'scatter',
        mode: 'lines+markers',
        name: `Cluster ${index + 1}`,
        line: { shape: 'linear' },
    }));

    const handleSliderChange = (e) => {
        setCCReportIndex(parseInt(e.target.value, 10));
    }

    const startPlayback = () => {
        if (intervalValue.current) return;   //if intervalValue has a value, don't go through with this function

        //intervalValue.current stores the ID returned by setInterval(callback, 1000)
        //by doing so, we are abel to cacnel it later on
        intervalValue.current = setInterval(() => {
            setCCReportIndex((prevIndex) => {
                const nextIndex = prevIndex + 1;
                if (nextIndex >= clusterCenters.length) {
                    return 0; // this loops back to beginning
                }
                return nextIndex;
            });
        }, 1000);
        setPlaying(true);
    };

    const stopPlayback = () => {
        clearInterval(intervalValue.current);
        intervalValue.current = null;
        setPlaying(false);
    };

    useEffect(() => {
        return () => clearInterval(intervalValue.current);
    }, []);

    return (
        <div>
            <div style={{ marginBottom: '10px' }}>
                <label>
                    Report Index: {ccReportIndex + 1}
                    <input
                        type="range"
                        min="0"
                        max={clusterCenters.length - 1}
                        value={ccReportIndex}
                        onChange={handleSliderChange}
                        style={{ width: '100%' }}
                    />
                </label>
                <div style={{ marginTop: '10px' }}>
                    {!playing ? (<button onClick={startPlayback}>Play &#9654;</button>) : (<button onClick={stopPlayback}>Pause &#x23f8;</button>)}
                </div>
            </div>
            
            {/* start of plot */}
            <Plot
                data={traces}
                layout={
                    {
                        title: {
                            text: `Cluster Centers from Report ${ccReportIndex + 1}`,
                        },
                        xaxis: { title: 'Feature Index' },
                        yaxis: { title: 'Value' },
                        autosize: true,
                        margin: { l: 40, r: 20, t: 40, b: 40 },
                        annotations: [
                            {
                                text: `Cache Length: ${reportsCacheLength[ccReportIndex] || 0}`,
                                xref: 'paper',
                                yref: 'paper',
                                x: 1,
                                y: 1.02,
                                showarrow: false,
                                font: {
                                    size: 14,
                                    color: 'gray'
                                },
                                marginTop: '10px'
                            }
                        ],
                    }
                }
                config={{ responsive: true }}
            />
            {/* end of plot */}
        </div>
    );
}