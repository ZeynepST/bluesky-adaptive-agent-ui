import Plot from 'react-plotly.js';
import { useState, useRef, useEffect } from 'react';


//clusterCenters holds all of the cluster centers generated by each report
//recentClusterCenters holds only the most recent cluster centers generated by the latest report 
export default function ClusterCentersOT({ clusterCenters }) {

    /**
     * cc stands for cluster centers.
     * By using a useState for the report index, it ensures that whenever the report index changes, the traces as defined below is computed 
     * on the new currentCenters. 
     */
    const [ccReportIndex, setCCReportIndex] = useState(clusterCenters.length);

    //playing tracks whether the user wants to use the playback functionality 
    const [playing, setPlaying] = useState(false);

    /*intervalValue is defined using useRef because it's not needed for rendering
    - it stores the ID of the setInterval timer
    */
    const intervalValue = useRef(null);

    //this keeps track of which report the user is viewing (has the graph on). It is an array of values 
    const currentCenters = clusterCenters[ccReportIndex] || [];


    //In plotly, a trace refers to a collection of data. 
    //The map is iterating through an array of values. 
    const traces = currentCenters.map((center, index) => ({
        x: center.map((_, i) => i + 1),
        y: center,
        type: 'scatter',
        mode: 'lines+markers',
        name: `Cluster ${index + 1}`,
        line: { shape: 'linear' },
    }));

    const handleSliderChange = (e) => {
        setCCReportIndex(parseInt(e.target.value, 10));
    }

    const startPlayback = () => {
        if (intervalValue.current) return;   //if intervalValue has a value, don't go through with this function

        //intervalValue.current stores the ID returned by setInterval(callback, 1000)
        //by doing so, we are abel to cacnel it later on
        intervalValue.current = setInterval(() => {
            setCCReportIndex((prevIndex) => {
                const nextIndex = prevIndex + 1;
                if (nextIndex >= clusterCenters.length) {
                    return 0; // this loops back to beginning
                }
                return nextIndex;
            });
        }, 1000); 
        setPlaying(true);
    };

    const stopPlayback = () => {
        clearInterval(intervalValue.current); 
        intervalValue.current = null;
        setPlaying(false);
    };

    useEffect(() => {
        return () => clearInterval(intervalValue.current);
    }, []);

    return (
        <div>
            <div style={{ marginBottom: '10px' }}>
                <label>
                    Report Index: {ccReportIndex + 1}
                    <input
                        type="range"
                        min="0"
                        max={clusterCenters.length - 1}
                        value={ccReportIndex}
                        onChange={handleSliderChange}
                        style={{ width: '100%' }}
                    />
                </label>
                <div style={{ marginTop: '10px' }}>
                    {!playing ? (<button onClick={startPlayback}>Play &#9654;</button>) : (<button onClick={stopPlayback}>Pause &#x23f8;</button>)}
                </div>
            </div>

            <Plot
                data={traces}
                layout={
                    {
                        title: {
                            text: `Cluster Centers from Report ${ccReportIndex + 1}`,
                        },
                        xaxis: { title: 'Feature Index' },
                        yaxis: { title: 'Value' },
                        autosize: true,
                        margin: { l: 40, r: 20, t: 40, b: 40 },
                    }
                }
                config={{ responsive: true }}
            />
        </div>
    );
}